class ContentTimeComputer:
    """
    :param number_of_timepoints: константа, указывающая сколько временных промежутков мы смотрим (сейчас 7 дней,
     каждый час)
    :param expectation_math_change_coefficient: коэффициент, указывающий насколько мало изменится матожидание от одного
    замера (меняется с течением времени от 1 до const_expectation_math_change_coefficient
    :param const_expectation_math_change_coefficient: максимальное значение expectation_math_change_coefficient,
    !!!ВАЖНО!!! инициализируется пользователем в конструкторе
    :param counter_of_expectation_math_change_coefficient_change: счетчик количества замеров (нужен для ускорения
     построения модели)
    это все были переменные типа int
    :param expectation_of_users_online[]: массив, в котором содержится матожидание количества человек онлайн
    в определенный момент времени
    :param expectation_of_income_online[]: массив, в котором содержится матожидание количества человек, зашедших
    в онлайн между 2 замерами в определенный момент времени
    """

    number_of_timepoints = 168
    expectation_math_change_coefficient = 0
    const_expectation_math_change_coefficient = 0
    expectation_of_users_online = []
    expectation_of_income_online = []
    counter_of_expectation_math_change_coefficient_change = 0

    def __init__(self, const_expectation_math_change_coefficient_input):
        self.const_expectation_math_change_coefficient = const_expectation_math_change_coefficient_input
        for i in range(self.number_of_timepoints):
            self.expectation_of_users_online.append(0)
            self.expectation_of_income_online.append(0)

    def counting_new_online(self, user_list_were, user_list_now):
        """
        работает за O(m+n)
        где m, n - количества пользователей

        :param user_list_were: массив, содержащие айдишники пользователей которые были в предыдущем просмотре [int]
        :param user_list_now: массив, содержащие айдишники пользователей в текущем просмотре [int]
        :return: возвращаем число присоединившихся int
        """
        count = 0
        i = 0
        j = 0
        while i < len(user_list_were):
            while j < len(user_list_now):
                if user_list_now[j] == user_list_were[i]:
                    count += 1
                    j += 1
                    break
                elif user_list_now[j] > user_list_were[i]:
                    break
                j += 1
            i += 1
        return len(user_list_now) - count

    def correct_number_of_online(self, time, number_of_online_now):
        """
        корректируем матожидание количества пользователей онлайн

        :param number_of_online_now: количество пользователей онлайн в данный момент времени
        :param time: время корректировки - целое число, интервал разбиения суток на такие периоды задаем константой
        """
        self.correct_expectation_math_change_coefficient()

        self.expectation_of_users_online[time] = number_of_online_now *\
        (1 - 1 / self.expectation_math_change_coefficient) +\
        (self.expectation_of_users_online[time]) / self.expectation_math_change_coefficient

    def correct_income_online(self, time, user_list_were, user_list_now):
        """
        корректируем матожидание количества пользователей зашедших в онлайн

        :param user_list_were: (см. описание соответствующей функции)
        :param user_list_now:
        :param time: (см. ранее)
        """
        self.correct_expectation_math_change_coefficient()

        self.expectation_of_income_online[time] = self.counting_new_online(user_list_were, user_list_now) * \
        (1 - 1 / self.expectation_math_change_coefficient) + \
        (self.expectation_of_users_online[time]) / self.expectation_math_change_coefficient

    def calculate_effective_time(self):
        """
        :return: возвращаем время в которое пост наберет наибольшее количество просмотров
        """
        time_max = 0
        for i in range(self.number_of_timepoints):
            if self.expectation_of_users_online[i]+self.expectation_of_income_online[(i + 1) % self.number_of_timepoints] > \
               self.expectation_of_users_online[time_max]+self.expectation_of_income_online[(time_max + 1) % self.number_of_timepoints]:
                time_max = i
        return time_max

    def correct_expectation_math_change_coefficient(self):
        """
        корректируем коэффициент изменения матожидания (иначе статистика будет собираться млрд лет)
        """
        if self.counter_of_expectation_math_change_coefficient_change % self.number_of_timepoints == 0 and \
           self.const_expectation_math_change_coefficient > self.expectation_math_change_coefficient:
            self.expectation_math_change_coefficient += 1

        self.counter_of_expectation_math_change_coefficient_change += 1
